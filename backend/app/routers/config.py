import logging
import mimetypes
from typing import Any

from fastapi import APIRouter, HTTPException, Response
from fastapi.responses import FileResponse
from pydantic import BaseModel

from app.config.agents import agents_config
from app.config.db.eval_db import eval_db_config
from app.config.db.human_signals import human_signals_db_config
from app.config.db.kpi import kpi_db_config
from app.config.db.monitoring import monitoring_db_config
from app.config.env import settings
from app.config.paths import get_custom_dir
from app.config.theme import theme_config
from app.plugins import discover_plugins

logger = logging.getLogger(__name__)

router = APIRouter()


class ThemePaletteResponse(BaseModel):
    """Theme palette color values."""

    name: str
    primary: str
    primaryLight: str
    primaryDark: str
    primarySoft: str
    primaryPale: str
    accentGold: str
    accentSilver: str
    heroImage: str | None = None
    logoUrl: str | None = None
    faviconUrl: str | None = None
    appIconUrl: str | None = None
    # Hero image filter options
    heroContrast: float | None = None
    heroSaturation: float | None = None
    heroBrightness: float | None = None
    heroOpacity: float | None = None
    heroMode: str | None = None
    shimmerFrom: str | None = None
    shimmerTo: str | None = None


class BrandingResponse(BaseModel):
    """Branding text used throughout the application."""

    app_name: str = "AXIS"
    tagline: str = "AI Evaluation Platform"
    subtitle: str = "The AI Evaluation Studio"
    description: str = "Agent X-ray Interface & Statistics"
    report_footer: str = "Report generated by AXIS AI Evaluation Platform"
    docs_url: str = "https://ax-foundry.github.io/axis/"
    footer_name: str = "AXIS"
    footer_icon: str | None = None


class ThemeConfigResponse(BaseModel):
    """Theme configuration response."""

    success: bool
    active: str
    activePalette: ThemePaletteResponse
    palettes: dict[str, ThemePaletteResponse]
    branding: BrandingResponse


@router.get("/theme", response_model=ThemeConfigResponse)
async def get_theme() -> ThemeConfigResponse:
    """Get the current theme configuration.

    Returns the active palette name, the active palette colors,
    and all available palettes for the frontend to use.
    """
    active_palette = theme_config.get_active_palette()

    branding = theme_config.branding
    return ThemeConfigResponse(
        success=True,
        active=theme_config.active,
        branding=BrandingResponse(
            app_name=branding.app_name,
            tagline=branding.tagline,
            subtitle=branding.subtitle,
            description=branding.description,
            report_footer=branding.report_footer,
            docs_url=branding.docs_url,
            footer_name=branding.footer_name or branding.app_name,
            footer_icon=branding.footer_icon or None,
        ),
        activePalette=ThemePaletteResponse(
            name=active_palette.name,
            primary=active_palette.primary,
            primaryLight=active_palette.primaryLight,
            primaryDark=active_palette.primaryDark,
            primarySoft=active_palette.primarySoft,
            primaryPale=active_palette.primaryPale,
            accentGold=active_palette.accentGold,
            accentSilver=active_palette.accentSilver,
            heroImage=active_palette.heroImage,
            logoUrl=active_palette.logoUrl,
            faviconUrl=active_palette.faviconUrl,
            appIconUrl=active_palette.appIconUrl,
            heroContrast=active_palette.heroContrast,
            heroSaturation=active_palette.heroSaturation,
            heroBrightness=active_palette.heroBrightness,
            heroOpacity=active_palette.heroOpacity,
            heroMode=active_palette.heroMode,
            shimmerFrom=active_palette.shimmerFrom,
            shimmerTo=active_palette.shimmerTo,
        ),
        palettes={
            name: ThemePaletteResponse(
                name=palette.name,
                primary=palette.primary,
                primaryLight=palette.primaryLight,
                primaryDark=palette.primaryDark,
                primarySoft=palette.primarySoft,
                primaryPale=palette.primaryPale,
                accentGold=palette.accentGold,
                accentSilver=palette.accentSilver,
                heroImage=palette.heroImage,
                logoUrl=palette.logoUrl,
                faviconUrl=palette.faviconUrl,
                appIconUrl=palette.appIconUrl,
                heroContrast=palette.heroContrast,
                heroSaturation=palette.heroSaturation,
                heroBrightness=palette.heroBrightness,
                heroOpacity=palette.heroOpacity,
                heroMode=palette.heroMode,
                shimmerFrom=palette.shimmerFrom,
                shimmerTo=palette.shimmerTo,
            )
            for name, palette in theme_config.palettes.items()
        },
    )


@router.get("/visibility")
async def get_visibility_config() -> dict[str, Any]:
    """Get the metric visibility configuration for all dashboards."""
    return {
        "kpi": {
            "visible_kpis": kpi_db_config.visible_kpis,
            "visible_kpis_per_source": kpi_db_config.visible_kpis_per_source,
        },
        "monitoring": {"visible_metrics": monitoring_db_config.visible_metrics},
        "human_signals": {
            "visible_metrics": human_signals_db_config.visible_metrics,
            "visible_kpis": human_signals_db_config.visible_kpis,
        },
    }


class AgentConfigResponse(BaseModel):
    """Agent configuration for the SourceSelector."""

    name: str
    label: str
    role: str | None = None
    avatar: str | None = None
    description: str | None = None
    biography: str | None = None
    active: bool = True
    trace_names: list[str] = []


class AgentsConfigResponse(BaseModel):
    """Agents configuration response."""

    success: bool
    agents: list[AgentConfigResponse]


@router.get("/agents", response_model=AgentsConfigResponse)
async def get_agents() -> AgentsConfigResponse:
    """Get the agent registry configuration.

    Returns the list of configured agents for the frontend
    SourceSelector and other agent-aware components.
    """
    return AgentsConfigResponse(
        success=True,
        agents=[
            AgentConfigResponse(
                name=agent.name,
                label=agent.label,
                role=agent.role,
                avatar=agent.avatar,
                description=agent.description,
                biography=agent.biography,
                active=agent.active,
                trace_names=agent.trace_names,
            )
            for agent in agents_config
        ],
    )


class FeaturesResponse(BaseModel):
    """Feature flags for the frontend."""

    eval_runner_enabled: bool = True
    copilot_enabled: bool = True


@router.get("/features", response_model=FeaturesResponse)
async def get_features() -> FeaturesResponse:
    """Get feature flags for the frontend.

    Returns toggles that control which features are available in the UI.
    """
    return FeaturesResponse(
        eval_runner_enabled=eval_db_config.eval_runner_enabled,
        copilot_enabled=settings.copilot_enabled,
    )


@router.get("/memory", deprecated=True)
async def get_memory_config_deprecated(response: Response) -> dict[str, Any]:
    """Deprecated — use GET /api/memory/config instead.

    Returns the same JSON payload as the canonical endpoint plus
    deprecation signals in headers and body.
    """
    from app.plugins.memory.routers.memory import _build_memory_config_response

    logger.warning("Deprecated endpoint /api/config/memory called")

    result = _build_memory_config_response()
    result["_deprecated"] = "/api/config/memory → /api/memory/config"

    response.headers["Deprecation"] = "true"
    response.headers["Link"] = '</api/memory/config>; rel="successor-version"'
    response.headers["Sunset"] = "2026-04-01"
    return result


@router.get("/plugins")
async def get_plugins() -> dict[str, Any]:
    """Return all discovered plugins (including disabled ones)."""
    return {
        "plugins": [
            {
                "name": e["meta"].name,
                "version": e["meta"].version,
                "api_version": e["meta"].api_version,
                "description": e["meta"].description,
                "nav": [n.model_dump() for n in e["meta"].nav],
                "enabled": e["enabled"],
                "error": e["error"],
            }
            for e in discover_plugins()
        ]
    }


_ASSET_TYPES = {"branding", "agents"}
_CACHE_HEADERS = {
    "branding": "public, max-age=31536000, immutable",
    "agents": "public, max-age=86400",
}


@router.get("/assets/{asset_type}/{filename}")
async def get_asset(asset_type: str, filename: str) -> FileResponse:
    """Serve static assets from custom/branding/ or custom/agents/.

    Used by Vercel-hosted frontends that cannot bundle branding files
    at build time. The backend proxies assets from CUSTOM_DIR so the
    frontend only needs NEXT_PUBLIC_API_URL.
    """
    if asset_type not in _ASSET_TYPES:
        raise HTTPException(status_code=404, detail="Not found")

    base = (get_custom_dir() / asset_type).resolve()
    path = (base / filename).resolve()

    # Path-traversal protection
    if not path.is_relative_to(base) or not path.is_file():
        raise HTTPException(status_code=404, detail="Not found")

    media_type = mimetypes.guess_type(path.name)[0] or "application/octet-stream"
    return FileResponse(
        path,
        media_type=media_type,
        headers={"Cache-Control": _CACHE_HEADERS[asset_type]},
    )
